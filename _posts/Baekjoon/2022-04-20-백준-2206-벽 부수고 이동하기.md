---
layout: single
title: "[백준] 2206. 벽 부수고 이동하기"
comments: true
category: Baekjoon
--- 

## 2206.   벽 부수고 이동하기

---

### Code

```java
package Backjoon;

import java.io.*;
import java.util.*;

public class 벽부수고이동하기_2206 {
    static int N, M;
    static int[][] map;
    static int[][][] dist;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        map = new int[N][M];
        dist = new int[N][M][2];
        // dist[x][y][0] : 벽을 하나도 부수지 않고 (x,y)까지 오는데 걸리는 비용
        // dist[x][y][1] : 벽을 하나만 부수고 (x,y)까지 오는데 비용, (x,y)가 벽이라서 부수는 경우 포함

        for(int i=0; i<N; i++){
            String str = br.readLine();
            for(int j=0; j<M; j++){
                int num = str.charAt(j)-'0';
                map[i][j] = num;
                dist[i][j][0] = -1;
                dist[i][j][1] = -1;
            }
        }

        System.out.println(bfs());
    }

    static int bfs(){
        Queue<Pair> queue = new LinkedList<>();
        dist[0][0][0] = 1;
        dist[0][0][1] = 1;
        queue.add(new Pair(0, 0, 0));

        while(!queue.isEmpty()){
            Pair cur = queue.poll();

            if(cur.x == N-1 && cur.y == M-1){
                return dist[cur.x][cur.y][cur.broken];
            }

            for(int dir=0; dir<4; dir++){
                int nx = cur.x+dx[dir];
                int ny = cur.y+dy[dir];
                if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;
                if(dist[nx][ny][cur.broken] == -1 && map[nx][ny] == 0) {
                    dist[nx][ny][cur.broken] = dist[cur.x][cur.y][cur.broken]+1;
                    queue.add(new Pair(nx, ny, cur.broken));
                }
                // (nx,ny)를 부수는 경우
                if(cur.broken != 1 && map[nx][ny] == 1 && dist[nx][ny][1] == -1){
                    dist[nx][ny][1] = dist[cur.x][cur.y][cur.broken]+1;
                    queue.add(new Pair(nx, ny, 1));
                }
            }
        }
        return -1;
    }

    static class Pair{
        int x, y, broken;
        public Pair(int x, int y, int broken){
            this.x = x;
            this.y = y;
            this.broken = broken;
        }
    }
}

```